
const puppeteer = require('puppeteer-extra');
const StealthPlugin = require('puppeteer-extra-plugin-stealth');
const { createLogger } = require('../utils/logger');

puppeteer.use(StealthPlugin());

class PDPJAuthService {
  constructor() {
    this.browser = null;
    this.page = null;
    this.logger = createLogger('PDPJAuthService');
    this.config = {
      // URL completa direto da vari√°vel de ambiente
      pjeLoginUrl: process.env.PJE_URL || 'https://pje.cloud.tjpe.jus.br/1g/login.seam',
      portalUrl: process.env.PORTAL_URL || 'https://portaldeservicos.pdpj.jus.br',
      timeout: parseInt(process.env.TIMEOUT) || 90000,
      headless: process.env.HEADLESS !== 'false'
    };
  }

  async initialize() {
    try {
      this.browser = await puppeteer.launch({
        headless: this.config.headless,
        executablePath: process.env.PUPPETEER_EXECUTABLE_PATH || '/usr/bin/chromium',
        args: [
          '--no-sandbox',
          '--disable-setuid-sandbox',
          '--disable-dev-shm-usage',
          '--disable-gpu',
          '--disable-web-security',
          '--disable-features=IsolateOrigins,site-per-process',
          '--disable-background-timer-throttling',
          '--disable-backgrounding-occluded-windows',
          '--disable-renderer-backgrounding'
        ]
      });
      
      this.page = await this.browser.newPage();
      
      // Configurar interceptadores de rede para capturar tokens
      await this.setupNetworkInterceptors();
      
      // Configurar viewport e user-agent
      await this.page.setViewport({ width: 1920, height: 1080 });
      await this.page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36');
      
      this.logger.info('Browser inicializado com sucesso');
    } catch (error) {
      this.logger.error('Erro ao inicializar browser:', error);
      throw error;
    }
  }

  async setupNetworkInterceptors() {
    // Interceptar requisi√ß√µes para capturar tokens
    this.page.on('request', (request) => {
      const headers = request.headers();
      if (headers['authorization']) {
        this.capturedToken = headers['authorization'].replace('Bearer ', '');
        this.logger.info('Token capturado via intercepta√ß√£o de rede');
      }
    });

    // Interceptar respostas para capturar tokens de resposta
    this.page.on('response', async (response) => {
      const url = response.url();
      if (url.includes('token') || url.includes('auth')) {
        try {
          const json = await response.json();
          if (json.access_token) {
            this.capturedToken = json.access_token;
            this.logger.info('Token capturado da resposta:', url);
          }
        } catch (e) {
          // Ignorar respostas n√£o-JSON
        }
      }
    });
  }

  async delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // Fun√ß√£o para clique robusto
  async robustClick(selector, description = '') {
    this.logger.info(`üîò Tentando clique robusto em: ${description || selector}`);
    
    try {
      // M√âTODO 1: Clique normal
      const element = await this.page.$(selector);
      if (!element) {
        throw new Error(`Elemento n√£o encontrado: ${selector}`);
      }
      
      // Verificar se elemento est√° vis√≠vel
      const isVisible = await element.evaluate(el => {
        const style = window.getComputedStyle(el);
        return style.display !== 'none' && style.visibility !== 'hidden' && el.offsetParent !== null;
      });
      
      this.logger.info(`üëÅÔ∏è Elemento vis√≠vel: ${isVisible}`);
      
      if (isVisible) {
        try {
          await element.click();
          this.logger.info('‚úÖ Clique normal funcionou!');
          return true;
        } catch (clickError) {
          this.logger.warn('‚ö†Ô∏è Clique normal falhou:', clickError.message);
        }
      }
      
      // M√âTODO 2: Scroll e clique
      this.logger.info('üîÑ Tentando scroll + clique...');
      try {
        await element.scrollIntoView();
        await this.delay(500);
        await element.click();
        this.logger.info('‚úÖ Scroll + clique funcionou!');
        return true;
      } catch (scrollClickError) {
        this.logger.warn('‚ö†Ô∏è Scroll + clique falhou:', scrollClickError.message);
      }
      
      // M√âTODO 3: JavaScript click
      this.logger.info('üîÑ Tentando JavaScript click...');
      try {
        await this.page.evaluate((sel) => {
          const element = document.querySelector(sel);
          if (element) {
            element.click();
            return true;
          }
          return false;
        }, selector);
        this.logger.info('‚úÖ JavaScript click funcionou!');
        return true;
      } catch (jsClickError) {
        this.logger.warn('‚ö†Ô∏è JavaScript click falhou:', jsClickError.message);
      }
      
      // M√âTODO 4: Submit do form (se for um bot√£o submit)
      this.logger.info('üîÑ Tentando submit do form...');
      try {
        await this.page.evaluate((sel) => {
          const element = document.querySelector(sel);
          if (element && element.form) {
            element.form.submit();
            return true;
          }
          return false;
        }, selector);
        this.logger.info('‚úÖ Submit do form funcionou!');
        return true;
      } catch (submitError) {
        this.logger.warn('‚ö†Ô∏è Submit do form falhou:', submitError.message);
      }
      
      // M√âTODO 5: Enter key
      this.logger.info('üîÑ Tentando Enter key...');
      try {
        await element.focus();
        await this.page.keyboard.press('Enter');
        this.logger.info('‚úÖ Enter key funcionou!');
        return true;
      } catch (enterError) {
        this.logger.warn('‚ö†Ô∏è Enter key falhou:', enterError.message);
      }
      
      throw new Error('Todos os m√©todos de clique falharam');
      
    } catch (error) {
      this.logger.error(`‚ùå Erro no clique robusto: ${error.message}`);
      throw error;
    }
  }

  async authenticate(username, password) {
    try {
      this.logger.info('üöÄ Iniciando autentica√ß√£o para usu√°rio:', username);
      
      // ‚úÖ USAR URL COMPLETA DA VARI√ÅVEL!
      const loginUrl = this.config.pjeLoginUrl;
      this.logger.info('üåê Navegando para URL:', loginUrl);
      
      const response = await this.page.goto(loginUrl, {
        waitUntil: 'networkidle2',
        timeout: this.config.timeout
      });

      this.logger.info('‚úÖ P√°gina carregada com sucesso!');
      this.logger.info('üìä Status HTTP:', response?.status());
      this.logger.info('üåê URL atual:', this.page.url());

      // Aguardar p√°gina carregar completamente
      await this.delay(3000);
      
      // Verificar t√≠tulo da p√°gina
      const title = await this.page.title();
      this.logger.info('üìÑ T√≠tulo da p√°gina:', title);

      // Aguardar por campos de login
      this.logger.info('üîç Aguardando campos de login...');
      
      try {
        await this.page.waitForSelector('input[name="j_username"], input[id="j_username"], input[name="username"]', {
          timeout: 30000
        });
        this.logger.info('‚úÖ Campo de username encontrado!');
      } catch (error) {
        this.logger.error('‚ùå Timeout aguardando campo de username');
        
        // Debug: listar todos os inputs
        const inputs = await this.page.$$eval('input', els => 
          els.map(el => ({
            name: el.name || 'N/A',
            id: el.id || 'N/A',
            type: el.type || 'N/A',
            placeholder: el.placeholder || 'N/A'
          }))
        );
        this.logger.info('üîç Inputs encontrados:', inputs);
        
        throw new Error('Campo de username n√£o encontrado ap√≥s timeout');
      }

      // Tentar diferentes seletores para username
      const usernameSelectors = [
        'input[name="j_username"]',
        'input[id="j_username"]', 
        'input[name="username"]',
        'input[id="username"]',
        'input[type="text"]'
      ];

      let usernameInput = null;
      for (const selector of usernameSelectors) {
        try {
          usernameInput = await this.page.$(selector);
          if (usernameInput) {
            this.logger.info('‚úÖ Campo username encontrado com seletor:', selector);
            break;
          }
        } catch (e) {
          continue;
        }
      }

      if (!usernameInput) {
        throw new Error('Nenhum campo de username encontrado na p√°gina');
      }

      // Tentar diferentes seletores para password
      const passwordSelectors = [
        'input[name="j_password"]',
        'input[id="j_password"]',
        'input[name="password"]',
        'input[id="password"]',
        'input[type="password"]'
      ];

      let passwordInput = null;
      for (const selector of passwordSelectors) {
        try {
          passwordInput = await this.page.$(selector);
          if (passwordInput) {
            this.logger.info('‚úÖ Campo password encontrado com seletor:', selector);
            break;
          }
        } catch (e) {
          continue;
        }
      }

      if (!passwordInput) {
        throw new Error('Nenhum campo de password encontrado na p√°gina');
      }

      // Preencher credenciais
      this.logger.info('üìù Preenchendo credenciais...');
      
      await usernameInput.click({ clickCount: 3 }); // Selecionar tudo
      await this.page.keyboard.type(username);
      await this.delay(500);

      await passwordInput.click({ clickCount: 3 }); // Selecionar tudo  
      await this.page.keyboard.type(password);
      await this.delay(500);

      this.logger.info('‚úÖ Credenciais preenchidas');

      // Procurar bot√£o de login com estrat√©gia robusta
      const loginButtonSelectors = [
        'button[type="submit"]',
        'input[type="submit"]',
        'button:contains("Entrar")',
        'button:contains("Login")',
        'input[value*="Entrar"]',
        'input[value*="Login"]',
        '.btn-primary',
        '.botao-login'
      ];

      let loginSuccess = false;

      for (const selector of loginButtonSelectors) {
        try {
          const loginButton = await this.page.$(selector);
          if (loginButton) {
            this.logger.info('‚úÖ Bot√£o login encontrado com seletor:', selector);
            
            try {
              await this.robustClick(selector, `Bot√£o de login (${selector})`);
              loginSuccess = true;
              break;
            } catch (clickError) {
              this.logger.warn(`‚ö†Ô∏è Falhou ao clicar em ${selector}:`, clickError.message);
              continue;
            }
          }
        } catch (e) {
          continue;
        }
      }

      if (!loginSuccess) {
        // √öltimo recurso: Enter no campo de password
        this.logger.info('üîÑ √öltimo recurso: Enter no campo password...');
        try {
          await passwordInput.focus();
          await this.page.keyboard.press('Enter');
          loginSuccess = true;
        } catch (enterError) {
          throw new Error('Nenhum m√©todo de submit funcionou');
        }
      }

      // ============================================================================
      // TIMEOUT DIN√ÇMICO CORRIGIDO
      // ============================================================================
      this.logger.info('‚è≥ Aguardando resposta do login...');
      
      let loginResult = null;
      try {
          loginResult = await Promise.race([
              // OP√á√ÉO 1: Aguardar redirecionamento (LOGIN SUCESSO)
              this.page.waitForFunction(
                  (loginUrl) => window.location.href !== loginUrl,
                  { timeout: 15000 },
                  this.config.pjeLoginUrl // ‚úÖ CORRIGIDO
              ).then(() => ({ status: 'redirected', url: this.page.url() })),
              
              // OP√á√ÉO 2: Aguardar mensagem de erro aparecer
              this.page.waitForSelector('.error, .alert, [class*="error"], [id*="error"], .message', { 
                  timeout: 15000,
                  visible: true 
              }).then(async (errorElement) => {
                  const errorText = await errorElement.textContent();
                  return { status: 'error', message: errorText.trim() };
              }),
              
              // OP√á√ÉO 3: Aguardar qualquer mudan√ßa no DOM (fallback)
              this.page.waitForFunction(
                  () => document.readyState === 'complete',
                  { timeout: 15000 }
              ).then(() => ({ status: 'completed', url: this.page.url() }))
          ]);
          
          this.logger.info('üéØ Resultado do login:', loginResult); // ‚úÖ CORRIGIDO
          
      } catch (timeoutError) {
          this.logger.warn('‚è∞ Timeout aguardando resposta do login'); // ‚úÖ CORRIGIDO
          loginResult = { status: 'timeout', url: this.page.url() };
      }
      
      // AN√ÅLISE DETALHADA DA RESPOSTA
      const currentUrl = this.page.url(); // ‚úÖ CORRIGIDO
      this.logger.info('üåê URL ap√≥s login:', { url: currentUrl });

      // Se ainda na p√°gina de login, capturar detalhes do erro
      if (currentUrl === this.config.pjeLoginUrl || currentUrl.includes('login.seam')) { // ‚úÖ CORRIGIDO
          
          // CAPTURAR MENSAGENS DE ERRO
          const errorMessages = await this.page.evaluate(() => { // ‚úÖ CORRIGIDO
              const selectors = [
                  '.error', '.alert', '.message', '.warning',
                  '[class*="error"]', '[class*="alert"]',
                  '[id*="error"]', '[id*="message"]',
                  '.validation-message', '.field-error',
                  '.ui-messages-error', '.ui-messages-warn'
              ];
              
              const messages = [];
              selectors.forEach(selector => {
                  const elements = document.querySelectorAll(selector);
                  elements.forEach(el => {
                      const text = el.textContent.trim();
                      if (text && text.length > 0) {
                          messages.push({ 
                              selector, 
                              text,
                              visible: el.offsetParent !== null
                          });
                      }
                  });
              });
              
              return messages;
          });
          
          if (errorMessages.length > 0) {
              this.logger.error('üìÑ Mensagens de erro encontradas:', { errorMessages }); // ‚úÖ CORRIGIDO
          }
          
          // VERIFICAR CAPTCHA
          const captchaExists = await this.page.evaluate(() => { // ‚úÖ CORRIGIDO
              const captchaSelectors = [
                  '.captcha', '[id*="captcha"]', '[class*="captcha"]',
                  '.recaptcha', '.g-recaptcha',
                  'iframe[src*="recaptcha"]',
                  'canvas', 'img[src*="captcha"]',
                  '[data-sitekey]'
              ];
              
              const found = [];
              captchaSelectors.forEach(selector => {
                  const element = document.querySelector(selector);
                  if (element) {
                      found.push({
                          selector,
                          visible: element.offsetParent !== null,
                          text: element.textContent?.trim() || 'N/A'
                      });
                  }
              });
              
              return found;
          });
          
          if (captchaExists.length > 0) {
              this.logger.warn('ü§ñ CAPTCHA detectado:', { captchaExists }); // ‚úÖ CORRIGIDO
          }
          
          // VERIFICAR CAMPOS OBRIGAT√ìRIOS
          const missingFields = await this.page.evaluate(() => { // ‚úÖ CORRIGIDO
              const required = document.querySelectorAll('[required]');
              const missing = [];
              required.forEach(field => {
                  if (!field.value || field.value.trim() === '') {
                      missing.push({
                          name: field.name || field.id || field.className,
                          type: field.type,
                          placeholder: field.placeholder || 'N/A'
                      });
                  }
              });
              return missing;
          });
          
          if (missingFields.length > 0) {
              this.logger.warn('üìã Campos obrigat√≥rios n√£o preenchidos:', { missingFields }); // ‚úÖ CORRIGIDO
          }
          
          // SCREENSHOT PARA DEBUG (apenas em desenvolvimento)
          if (process.env.NODE_ENV !== 'production') {
              try {
                  await this.page.screenshot({ // ‚úÖ CORRIGIDO
                      path: `/tmp/login-failed-${Date.now()}.png`,
                      fullPage: true 
                  });
                  this.logger.info('üì∏ Screenshot salvo para an√°lise'); // ‚úÖ CORRIGIDO
              } catch (screenshotError) {
                  this.logger.warn('üì∏ Falha ao capturar screenshot:', { error: screenshotError.message }); // ‚úÖ CORRIGIDO
              }
          }
          
          // DETERMINAR TIPO DE ERRO
          let errorMessage = 'Login n√£o foi bem-sucedido - ainda na p√°gina de login';
          
          if (captchaExists.length > 0) {
              errorMessage = 'Login bloqueado por CAPTCHA - autentica√ß√£o autom√°tica n√£o poss√≠vel';
          } else if (errorMessages.length > 0) {
              const mainError = errorMessages.find(err => err.visible)?.text || errorMessages[0]?.text;
              errorMessage = `Login rejeitado: ${mainError}`;
          } else if (missingFields.length > 0) {
              errorMessage = `Campos obrigat√≥rios n√£o preenchidos: ${missingFields.map(f => f.name).join(', ')}`;
          }
          
          throw new Error(errorMessage);
      }
      
      // Se chegou aqui, login foi bem-sucedido
      this.logger.info('‚úÖ Login bem-sucedido - redirecionado para:', { url: currentUrl }); // ‚úÖ CORRIGIDO

      // Tentar extrair token
      const token = await this.extractToken();
      
      if (!token) {
        this.logger.warn('‚ö†Ô∏è Token n√£o encontrado, mas login foi bem-sucedido');
        // Retornar um token mock ou identificador de sess√£o
        return {
          success: true,
          token: 'session_authenticated',
          message: 'Login bem-sucedido sem token espec√≠fico'
        };
      }

      this.logger.info('üéØ Token extra√≠do com sucesso');
      
      return {
        success: true,
        token: token,
        message: 'Autentica√ß√£o realizada com sucesso'
      };

    } catch (error) {
      this.logger.error('‚ùå Erro durante autentica√ß√£o:', error.message);
      throw error;
    }
  }

  async checkLoginSuccess() {
    try {
      const url = this.page.url();
      
      // Verificar se n√£o est√° mais na p√°gina de login
      const isNotLoginPage = !url.includes('login.seam');
      
      if (isNotLoginPage) {
        this.logger.info('‚úÖ N√£o est√° mais na p√°gina de login');
        return true;
      }
      
      // Verificar elementos que indicam login bem-sucedido
      const successIndicators = [
        'span.usuario-logado',
        'div.user-info', 
        'a[href*="logout"]',
        '.menu-principal',
        '.painel-usuario'
      ];
      
      for (const selector of successIndicators) {
        try {
          const element = await this.page.$(selector);
          if (element) {
            this.logger.info('‚úÖ Indicador de sucesso encontrado:', selector);
            return true;
          }
        } catch (e) {
          continue;
        }
      }
      
      return false;
    } catch (error) {
      this.logger.error('Erro ao verificar sucesso do login:', error);
      return false;
    }
  }

  async extractToken() {
    try {
      // Verificar localStorage
      const localStorageToken = await this.page.evaluate(() => {
        const keys = ['access_token', 'accessToken', 'token', 'auth_token'];
        for (const key of keys) {
          const value = localStorage.getItem(key);
          if (value) return value;
        }
        return null;
      });

      if (localStorageToken) {
        this.logger.info('Token encontrado no localStorage');
        return localStorageToken;
      }

      // Verificar sessionStorage
      const sessionStorageToken = await this.page.evaluate(() => {
        const keys = ['access_token', 'accessToken', 'token', 'auth_token'];
        for (const key of keys) {
          const value = sessionStorage.getItem(key);
          if (value) return value;
        }
        return null;
      });

      if (sessionStorageToken) {
        this.logger.info('Token encontrado no sessionStorage');
        return sessionStorageToken;
      }

      // Verificar cookies
      const cookies = await this.page.cookies();
      const tokenCookie = cookies.find(c => 
        c.name.toLowerCase().includes('token') || 
        c.name.toLowerCase().includes('auth') ||
        c.name.toLowerCase().includes('session')
      );

      if (tokenCookie) {
        this.logger.info('Token encontrado nos cookies:', tokenCookie.name);
        return tokenCookie.value;
      }

      // Token capturado via intercepta√ß√£o
      if (this.capturedToken) {
        this.logger.info('Usando token capturado da rede');
        return this.capturedToken;
      }

      // Verificar Keycloak
      const keycloakToken = await this.page.evaluate(() => {
        if (window.keycloak && window.keycloak.token) {
          return window.keycloak.token;
        }
        return null;
      });

      if (keycloakToken) {
        this.logger.info('Token encontrado no Keycloak');
        return keycloakToken;
      }

      this.logger.info('Nenhum token espec√≠fico encontrado');
      return null;
    } catch (error) {
      this.logger.error('Erro ao extrair token:', error);
      return null;
    }
  }

  async validatePortalAccess(token) {
    try {
      await this.page.setExtraHTTPHeaders({
        'Authorization': `Bearer ${token}`
      });

      await this.page.goto(`${this.config.portalUrl}/consulta`, {
        waitUntil: 'networkidle2',
        timeout: this.config.timeout
      });

      const isAuthorized = await this.page.evaluate(() => {
        const url = window.location.href;
        return !url.includes('login') && !url.includes('unauthorized');
      });

      return isAuthorized;
    } catch (error) {
      this.logger.error('Erro ao validar acesso ao portal:', error);
      return false;
    }
  }

  async searchProcess(processNumber, token) {
    try {
      await this.page.setExtraHTTPHeaders({
        'Authorization': `Bearer ${token}`
      });

      await this.page.goto(`${this.config.portalUrl}/consulta`, {
        waitUntil: 'networkidle2'
      });

      await this.page.waitForSelector('input[name="numeroProcesso"], input[id="numeroProcesso"]', {
        timeout: this.config.timeout
      });

      await this.page.type('input[name="numeroProcesso"], input[id="numeroProcesso"]', processNumber);

      await Promise.all([
        this.page.waitForNavigation({ waitUntil: 'networkidle2' }),
        this.page.click('button[type="submit"], button#btnBuscar')
      ]);

      await this.page.waitForSelector('table.resultados, div.processo-info', {
        timeout: this.config.timeout
      });

      const processData = await this.page.evaluate(() => {
        const data = {
          numero: document.querySelector('.numero-processo')?.textContent,
          partes: Array.from(document.querySelectorAll('.parte')).map(el => el.textContent),
          movimentacoes: Array.from(document.querySelectorAll('.movimentacao')).map(el => ({
            data: el.querySelector('.data')?.textContent,
            descricao: el.querySelector('.descricao')?.textContent
          }))
        };
        return data;
      });

      return processData;
    } catch (error) {
      this.logger.error('Erro ao buscar processo:', error);
      throw error;
    }
  }

  async close() {
    if (this.browser) {
      await this.browser.close();
      this.logger.info('Browser fechado');
    }
  }
}

module.exports = PDPJAuthService;
